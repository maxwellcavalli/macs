<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>MACS Chat Console</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", "Segoe UI", sans-serif;
    }
    body {
      background: #0f172a;
      color: #e2e8f0;
      margin: 0;
    }
    .chat-scroll {
      scrollbar-width: thin;
      scrollbar-color: rgba(148,163,184,0.35) transparent;
    }
    .chat-scroll::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    .chat-scroll::-webkit-scrollbar-thumb {
      background-color: rgba(148,163,184,0.35);
      border-radius: 999px;
    }
    pre {
      margin: 0;
    }
    @keyframes shimmer {
      0% { background-position: -150% 0; }
      100% { background-position: 150% 0; }
    }
    .processing .shimmer-text {
      position: relative;
      background: linear-gradient(90deg, rgba(148,163,184,0.2) 0%, rgba(226,232,240,0.6) 50%, rgba(148,163,184,0.2) 100%);
      background-size: 200% 100%;
      background-clip: text;
      -webkit-background-clip: text;
      animation: shimmer 2.4s ease-in-out infinite;
      color: transparent;
    }
  </style>
</head>
<body class="min-h-screen">
  <div class="min-h-screen flex flex-col">
    <header class="border-b border-slate-800 bg-slate-900/80 backdrop-blur">
      <div class="max-w-5xl mx-auto px-4 py-5 flex flex-col gap-4 md:flex-row md:items-end md:justify-between">
        <div>
          <h1 class="text-2xl font-semibold tracking-tight">MACS Chat</h1>
          <p class="text-sm text-slate-400">Conversational console for the multi-model router.</p>
        </div>
        <div class="flex flex-wrap gap-3 items-end">
          <label class="text-xs text-slate-400 flex flex-col gap-1">
            API Base
            <input id="apiBase" class="w-56 rounded-xl border border-slate-700 bg-slate-900 px-3 py-2 text-sm text-slate-200 focus:outline-none focus:ring focus:ring-indigo-500/40" placeholder="http://127.0.0.1:8080">
          </label>
          <label class="text-xs text-slate-400 flex flex-col gap-1">
            API Key
            <input id="apiKey" class="w-48 rounded-xl border border-slate-700 bg-slate-900 px-3 py-2 text-sm text-slate-200 focus:outline-none focus:ring focus:ring-indigo-500/40" placeholder="dev-...">
          </label>
          <button id="newChatBtn" class="rounded-xl border border-slate-700 bg-slate-900 px-4 py-2 text-sm text-slate-200 transition hover:bg-slate-800">New chat</button>
        </div>
      </div>
    </header>

    <main class="flex-1 py-6">
      <section class="max-w-6xl mx-auto px-4">
        <div class="grid gap-6 lg:grid-cols-[2fr,1fr] h-full">
          <div class="flex flex-col gap-4 h-full">
            <div class="flex-1 rounded-3xl border border-slate-800 bg-slate-900/60 backdrop-blur flex flex-col overflow-hidden">
              <div id="messages" class="chat-scroll flex-1 overflow-y-auto px-6 py-6 space-y-4">
                <div class="text-center text-sm text-slate-500">No messages yet. Say hi!</div>
              </div>
              <div class="border-t border-slate-800 bg-slate-900/80 px-4 py-3 flex flex-wrap items-center gap-3">
                <button type="button" id="memoryRefreshBtn" class="rounded-2xl border border-slate-700 bg-slate-900 px-3 py-1.5 text-xs font-medium text-slate-200 hover:bg-slate-800 transition">Find related work</button>
                <span id="memoryStatus" class="text-[0.75rem] text-slate-400 hidden"></span>
                <span id="contextUsageGlobal" class="text-[0.75rem] text-slate-400 hidden"></span>
              </div>
              <form id="composer" class="border-t border-slate-800 bg-slate-900/80 px-4 py-4 flex gap-3 items-end">
                <textarea id="messageInput" class="flex-1 min-h-[72px] max-h-52 resize-y rounded-2xl border border-slate-700 bg-slate-950 px-3 py-3 text-sm text-slate-100 focus:outline-none focus:ring focus:ring-indigo-500/40" placeholder="Type your message..."></textarea>
                <button type="submit" id="sendBtn" class="rounded-2xl bg-indigo-600 px-5 py-2.5 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-500 disabled:cursor-not-allowed disabled:opacity-50">Send</button>
              </form>
            </div>
            <aside class="text-xs text-slate-400">
              <p><span class="text-slate-200 font-medium">Tips:</span> chat requests are routed to conversational models. When the router is unsure, it will ask whether you want code or plain language.</p>
            </aside>
          </div>
          <aside id="memoryPanel" class="rounded-3xl border border-slate-800 bg-slate-900/60 backdrop-blur flex flex-col overflow-hidden">
            <header class="border-b border-slate-800 px-4 py-3 space-y-2">
              <div class="flex items-center justify-between gap-2">
                <div>
                  <h2 class="text-sm font-semibold text-slate-200">Workspace memory</h2>
                  <p class="text-xs text-slate-400 mt-1">Select up to three past completions to ground the next reply.</p>
                </div>
                <div class="flex items-center gap-2">
                  <button type="button" id="memoryUploadBtn" class="rounded-xl border border-slate-700 bg-slate-900 px-3 py-1.5 text-[0.7rem] font-medium text-slate-200 hover:bg-slate-800 transition">Attach code</button>
                  <input id="memoryUploadInput" type="file" accept=".zip" class="hidden" />
                </div>
              </div>
            </header>
            <div id="memoryList" class="chat-scroll flex-1 overflow-y-auto px-4 py-4 space-y-3 text-sm text-slate-300">
              <p class="text-sm text-slate-500">No related history yet. Click “Find related work” to search.</p>
            </div>
          </aside>
        </div>
      </section>
    </main>
  </div>

  <script>
    marked.setOptions({
      gfm: true,
      breaks: true,
      highlight: (code, lang) => {
        if (lang && hljs.getLanguage(lang)) {
          return hljs.highlight(code, { language: lang }).value;
        }
        return hljs.highlightAuto(code).value;
      }
    });

    const SESSION_KEY = "chat.sessionId";
    const state = {
      base: localStorage.getItem("chat.apiBase") || window.location.origin.replace(/\/chat\/?$/, ""),
      key: localStorage.getItem("chat.apiKey") || "",
      repoPath: localStorage.getItem("chat.repoPath") || "./workspace",
      sending: false,
      eventSource: null,
      sessionId: sessionStorage.getItem(SESSION_KEY) || "",
    };

    const memoryState = {
      results: [],
      selected: new Set(),
      loading: false,
      error: null,
      manualSelection: false,
    };

  const messagesEl = document.getElementById("messages");
  const inputEl = document.getElementById("messageInput");
  const sendBtn = document.getElementById("sendBtn");
  const apiBaseEl = document.getElementById("apiBase");
  const apiKeyEl = document.getElementById("apiKey");
  const newChatBtn = document.getElementById("newChatBtn");
  const composerForm = document.getElementById("composer");
  const contextUsageGlobalEl = document.getElementById("contextUsageGlobal");

    const conversation = [];

    const memoryListEl = document.getElementById("memoryList");
    const memoryStatusEl = document.getElementById("memoryStatus");
    const memoryRefreshBtn = document.getElementById("memoryRefreshBtn");
    const memoryUploadBtn = document.getElementById("memoryUploadBtn");
    const memoryUploadInput = document.getElementById("memoryUploadInput");

    const MAX_UPLOAD_BYTES = 10 * 1024 * 1024;

    function applyStateToInputs() {
      apiBaseEl.value = state.base;
      apiKeyEl.value = state.key;
    }

    function rememberSettings() {
      localStorage.setItem("chat.apiBase", state.base);
      localStorage.setItem("chat.apiKey", state.key);
      localStorage.setItem("chat.repoPath", state.repoPath);
    }

    function clearConversation() {
      conversation.length = 0;
      messagesEl.innerHTML = "";
      const ghost = document.createElement("div");
      ghost.className = "text-center text-sm text-slate-500";
      ghost.textContent = "Conversation cleared.";
      messagesEl.appendChild(ghost);
      memoryState.selected.clear();
    memoryState.results = [];
    memoryState.manualSelection = false;
    updateMemoryPanel();
    if (contextUsageGlobalEl) {
      contextUsageGlobalEl.classList.add("hidden");
      contextUsageGlobalEl.textContent = "";
    }
  }

    function scrollMessages() {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    const SUPPORTED_LANGUAGES = ["java", "python", "graphql"];

    function ensureSessionId() {
      if (state.sessionId) return state.sessionId;
      if (window.crypto && crypto.randomUUID) {
        state.sessionId = crypto.randomUUID();
      } else {
        state.sessionId = `sess-${Math.random().toString(16).slice(2, 10)}`;
      }
      sessionStorage.setItem(SESSION_KEY, state.sessionId);
      return state.sessionId;
    }

    function truncate(text, max) {
      if (!text) return "";
      if (text.length <= max) return text;
      return text.slice(0, max - 1) + "…";
    }

    function inferLanguage(message) {
      // Prefer selected memory languages
      for (const item of memoryState.results) {
        if (memoryState.selected.has(item.id) && item.language) {
          const lang = String(item.language).toLowerCase();
          if (SUPPORTED_LANGUAGES.includes(lang)) {
            return lang;
          }
        }
      }
      const text = (message || "").toLowerCase();
      if (text.includes("graphql")) return "graphql";
      if (text.includes("java")) return "java";
      if (text.includes("python")) return "python";
      return "python";
    }

    function normalizeRepoPath(value) {
      if (!value) return "./workspace";
      let s = String(value).trim().replace(/\\/g, "/");
      if (!s) return "./workspace";
      s = s.replace(/^\.\/+/, "");
      if (s.startsWith("workspace/")) s = s.slice("workspace/".length);
      if (s.startsWith("./workspace/")) s = s.slice("./workspace/".length);
      if (s === "workspace") s = "";
      if (s.startsWith("./")) s = s.slice(2);
      s = s.replace(/^\/+/, "");
      s = s.replace(/\/+$/, "");
      if (!s || s === ".") return "./workspace";
      return `./workspace/${s}`;
    }

    function setRepoPath(value) {
      const normalized = normalizeRepoPath(value);
      state.repoPath = normalized;
      localStorage.setItem("chat.repoPath", normalized);
    }

    function updateMemoryPanel() {
      const resultIds = new Set(memoryState.results.map(r => r.id));
      Array.from(memoryState.selected).forEach(id => {
        if (!resultIds.has(id)) {
          memoryState.selected.delete(id);
        }
      });

      if (memoryState.loading) {
        memoryStatusEl.textContent = "Searching workspace memories…";
        memoryStatusEl.classList.remove("hidden");
      } else if (memoryState.error) {
        memoryStatusEl.textContent = memoryState.error;
        memoryStatusEl.classList.remove("hidden");
      } else {
        memoryStatusEl.classList.add("hidden");
      }

      if (!memoryState.results.length) {
        memoryListEl.innerHTML = '<p class="text-sm text-slate-500">No related history yet. Click “Find related work” to search.</p>';
        return;
      }

      const frag = document.createDocumentFragment();
      memoryState.results.forEach((item) => {
        const card = document.createElement("button");
        const isSelected = memoryState.selected.has(item.id);
        card.type = "button";
        card.dataset.id = item.id;
        card.className = [
          "w-full text-left rounded-2xl border px-3 py-3 transition",
          isSelected
            ? "border-indigo-400 bg-indigo-500/20 text-indigo-100"
            : "border-slate-700 bg-slate-950/40 text-slate-200 hover:border-indigo-400/40 hover:bg-indigo-500/10"
        ].join(" ");

        const title = document.createElement("div");
        title.className = "text-xs font-semibold uppercase tracking-[0.2em] text-slate-400 mb-1";
        title.textContent = item.goal ? truncate(item.goal, 120) : "Workspace memory";

        const summary = document.createElement("p");
        summary.className = "text-xs leading-relaxed whitespace-pre-wrap";
        summary.textContent = truncate(item.summary || "(no summary)", 260);

        const meta = document.createElement("div");
        meta.className = "mt-2 text-[0.65rem] uppercase tracking-[0.2em] text-slate-500 flex gap-2";
        if (item.model) {
          const badge = document.createElement("span");
          badge.textContent = item.model;
          meta.appendChild(badge);
        }
        if (item.created_at) {
          const date = new Date(item.created_at);
          if (!isNaN(date)) {
            const badge = document.createElement("span");
            badge.textContent = date.toLocaleString();
            meta.appendChild(badge);
          }
        }

        card.appendChild(title);
        card.appendChild(summary);
        if (meta.childElementCount) {
          card.appendChild(meta);
        }
        frag.appendChild(card);
      });
      memoryListEl.innerHTML = "";
      memoryListEl.appendChild(frag);
    }

    async function fetchMemories(queryText) {
      if (!state.base) {
        memoryState.error = "Set API Base to search.";
        updateMemoryPanel();
        return;
      }
      memoryState.loading = true;
      memoryState.error = null;
      updateMemoryPanel();
      try {
        const trimmed = (queryText || "").trim();
        const headers = state.key ? { "x-api-key": state.key } : {};
        const sessionId = ensureSessionId();

        const sessionParams = new URLSearchParams({ limit: "5", session_id: sessionId });
        if (trimmed) sessionParams.set("query", trimmed.slice(0, 200));
        const globalParams = new URLSearchParams({ limit: "5" });
        if (trimmed) globalParams.set("query", trimmed.slice(0, 200));

        const base = state.base.replace(/\/$/, "");
        const [sessionResp, globalResp] = await Promise.all([
          fetch(`${base}/v1/memory/search?${sessionParams.toString()}`, { headers }),
          fetch(`${base}/v1/memory/search?${globalParams.toString()}`, { headers }),
        ]);

        if (!sessionResp.ok) throw new Error(`session HTTP ${sessionResp.status}`);
        if (!globalResp.ok) throw new Error(`global HTTP ${globalResp.status}`);

        const sessionData = await sessionResp.json();
        const globalData = await globalResp.json();
        const combined = [...(sessionData.memories || []), ...(globalData.memories || [])];

        const dedup = new Map();
        combined.forEach(item => {
          if (item && item.id) {
            if (!dedup.has(item.id)) {
              dedup.set(item.id, item);
            }
          }
        });

        const uniqueResults = Array.from(dedup.values());
        const sessionScoped = uniqueResults.filter(item => item && item.session_id && item.session_id === state.sessionId);
        const nextResults = sessionScoped.length ? sessionScoped : uniqueResults;
        memoryState.results = nextResults;
        if (!memoryState.manualSelection) {
          memoryState.selected = new Set(
            nextResults
              .filter(item => item && item.id)
              .map(item => item.id)
          );
        }
        const repoCandidate = nextResults.find(item => item && item.repo_path)?.repo_path;
        if (repoCandidate) {
          setRepoPath(repoCandidate);
        }
      } catch (err) {
        console.error("memory search failed", err);
        memoryState.error = `Search failed: ${err.message || err}`;
        memoryState.results = [];
      } finally {
        memoryState.loading = false;
        updateMemoryPanel();
      }
    }

    function toggleMemorySelection(id) {
      if (!id) return;
      if (memoryState.selected.has(id)) {
        memoryState.selected.delete(id);
        memoryState.manualSelection = true;
        updateMemoryPanel();
        return;
      }
      memoryState.selected.add(id);
      memoryState.error = null;
      memoryState.manualSelection = true;
      updateMemoryPanel();
    }

    async function uploadMemoryArchive(file) {
      if (!file) return;
      if (!state.base) {
        memoryState.error = "Set API Base first.";
        updateMemoryPanel();
        return;
      }
      if (file.size > MAX_UPLOAD_BYTES) {
        memoryState.error = "Archive too large (max 10MB).";
        updateMemoryPanel();
        return;
      }
      const form = new FormData();
      form.append("file", file, file.name);
      form.append("session_id", ensureSessionId());
      const headers = state.key ? { "x-api-key": state.key } : {};
      memoryState.loading = true;
      memoryState.error = null;
      updateMemoryPanel();
      try {
        const resp = await fetch(`${state.base.replace(/\/$/, "")}/v1/memory/upload`, {
          method: "POST",
          headers,
          body: form,
        });
        if (!resp.ok) {
          const detail = await resp.text();
          throw new Error(detail || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        if (data.session_id && data.session_id !== state.sessionId) {
          state.sessionId = data.session_id;
          sessionStorage.setItem(SESSION_KEY, state.sessionId);
        }
        if (data.workspace_path) {
          setRepoPath(data.workspace_path);
        } else if (data.repo_path) {
          setRepoPath(data.repo_path);
        }
        const incoming = Array.isArray(data.memories) ? data.memories : [];
        incoming.forEach(item => {
          if (item && item.id) {
            memoryState.selected.add(item.id);
          }
        });
        // Deduplicate combined results
        const existing = new Map(memoryState.results.map(item => [item.id, item]));
        incoming.forEach(item => {
          if (item && item.id) {
            existing.set(item.id, item);
          }
        });
        memoryState.results = Array.from(existing.values());
        await fetchMemories("");
      } catch (err) {
        console.error("upload failed", err);
        memoryState.error = `Upload failed: ${err.message || err}`;
      } finally {
        memoryState.loading = false;
        updateMemoryPanel();
      }
    }

    function decorateCodeBlocks(root) {
      const blocks = root.querySelectorAll("pre > code");
      blocks.forEach(codeEl => {
        const pre = codeEl.parentElement;
        const langMatch = (codeEl.className || "").match(/language-([\w.-]+)/);
        const lang = langMatch ? langMatch[1] : codeEl.getAttribute("data-lang") || "code";

        const wrapper = document.createElement("div");
        wrapper.className = "relative mt-4 rounded-2xl border border-slate-700 bg-slate-950/60 overflow-hidden";

        const header = document.createElement("div");
        header.className = "flex items-center justify-between border-b border-slate-800 bg-slate-900/80 px-4 py-2 text-xs uppercase tracking-wide text-slate-400";
        const label = document.createElement("span");
        label.textContent = lang;
        const actions = document.createElement("div");
        actions.className = "flex items-center gap-2";
        const selectBtn = document.createElement("button");
        selectBtn.type = "button";
        selectBtn.className = "rounded border border-slate-600 bg-slate-800 px-2 py-1 text-[0.7rem] text-slate-200 hover:bg-slate-700 select-btn";
        selectBtn.dataset.code = codeEl.textContent;
        selectBtn.textContent = "Select";
        const copyBtn = document.createElement("button");
        copyBtn.type = "button";
        copyBtn.className = "rounded border border-slate-600 bg-slate-800 px-2 py-1 text-[0.7rem] text-slate-200 hover:bg-slate-700 copy-btn";
        copyBtn.dataset.code = codeEl.textContent;
        copyBtn.textContent = "Copy";
        actions.appendChild(selectBtn);
        actions.appendChild(copyBtn);
        header.appendChild(label);
        header.appendChild(actions);

        pre.classList.add("px-4", "py-4", "overflow-x-auto");

        const parent = pre.parentElement;
        parent.replaceChild(wrapper, pre);
        wrapper.appendChild(header);
        wrapper.appendChild(pre);
      });
    }

    function renderMarkdown(target, text) {
      const html = marked.parse(text || "");
      target.innerHTML = html;
    decorateCodeBlocks(target);
    target.querySelectorAll("pre code").forEach(code => {
      hljs.highlightElement(code);
    });
  }

  function setGlobalContextUsage(promptTokens, completionTokens, ctxLimit) {
    if (!contextUsageGlobalEl) return;
    const hasPrompt = typeof promptTokens === "number" && promptTokens > 0;
    const hasCompletion = typeof completionTokens === "number" && completionTokens > 0;
    const total = (promptTokens || 0) + (completionTokens || 0);
    if (!hasPrompt && !hasCompletion && total === 0) {
      contextUsageGlobalEl.classList.add("hidden");
      contextUsageGlobalEl.textContent = "";
      return;
    }
    const parts = [];
    if (promptTokens != null) parts.push(`prompt ${promptTokens}`);
    if (completionTokens != null) parts.push(`completion ${completionTokens}`);
    let summary = parts.join(" • ");
    if (ctxLimit) {
      const pct = Math.min(100, Math.round((total / ctxLimit) * 100));
      summary += ` — ${pct}% of ${ctxLimit}`;
    }
    contextUsageGlobalEl.textContent = summary;
    contextUsageGlobalEl.classList.remove("hidden");
  }

  function renderContextUsage(container, payload) {
    if (!payload) return;
    const promptTokens = typeof payload.prompt_tokens === "number" ? payload.prompt_tokens : null;
    const completionTokens = typeof payload.completion_tokens === "number" ? payload.completion_tokens : null;
    const ctxLimit = typeof payload.ctx_limit === "number" ? payload.ctx_limit : null;
    if (promptTokens === null && completionTokens === null) return;
      const existing = container.querySelector(".context-usage");
      if (existing) {
        existing.remove();
      }
      const usage = document.createElement("div");
      usage.className = "context-usage mt-4 text-xs text-slate-400 flex flex-col gap-2";
      const line = document.createElement("div");
      const promptPart = `prompt ${promptTokens ?? 0}`;
      const completionPart = `completion ${completionTokens ?? 0}`;
      let summary = `Context: ${promptPart} • ${completionPart}`;
      let percent = null;
      if (ctxLimit && ctxLimit > 0) {
        const total = (promptTokens ?? 0) + (completionTokens ?? 0);
        percent = Math.min(100, Math.round((total / ctxLimit) * 100));
        summary += ` (limit ${ctxLimit})`;
      }
      line.textContent = summary;
      usage.appendChild(line);
      if (percent !== null) {
        const bar = document.createElement("div");
        bar.className = "h-1.5 rounded-full bg-slate-800/80 overflow-hidden";
        const fill = document.createElement("div");
        fill.className = "h-full bg-indigo-500/80";
        fill.style.width = `${percent}%`;
        bar.appendChild(fill);
      usage.appendChild(bar);
    }
    container.appendChild(usage);
    setGlobalContextUsage(promptTokens, completionTokens, ctxLimit);
  }

    function renderMessage(role, text, opts) {
      const options = opts || {};
      if (!text) text = "";
      if (messagesEl.children.length === 1 && messagesEl.firstElementChild && messagesEl.firstElementChild.textContent.startsWith("No messages")) {
        messagesEl.innerHTML = "";
      }
      const bubble = document.createElement("div");
      bubble.className = [
        "rounded-3xl px-4 py-4 max-w-[75%]",
        role === "user"
          ? "bg-indigo-600/20 border border-indigo-500/40 ml-auto"
          : "bg-slate-900/80 border border-slate-800"
      ].join(" ");

      const header = document.createElement("div");
      header.className = "text-[0.65rem] uppercase tracking-[0.2em] text-slate-400 mb-2";
      header.textContent = role === "user" ? "You" : "Assistant";

      let statusEl = null;
      if (options.pending) {
        statusEl = document.createElement("div");
        statusEl.className = "mb-2 text-xs text-slate-400 italic shimmer-text";
        statusEl.textContent = options.pendingMessage || "Thinking…";
      }

      const body = document.createElement("div");
      renderMarkdown(body, text);

      bubble.appendChild(header);
      if (statusEl) bubble.appendChild(statusEl);
      bubble.appendChild(body);
      messagesEl.appendChild(bubble);
      scrollMessages();

      if (options.persist !== false) {
        conversation.push({ role, content: text });
      }
      if (options.pending) {
        bubble.classList.add("processing");
      }
      return { container: bubble, body, status: statusEl };
    }

    function disableComposer(disabled) {
      state.sending = disabled;
      sendBtn.disabled = disabled;
      inputEl.disabled = disabled;
    }

    function toTaskPayload(message) {
      const language = inferLanguage(message);
      const sessionId = ensureSessionId();
      const repoPath = state.repoPath || "./workspace";
      return {
        type: "DOC",
        input: {
          language,
          frameworks: [],
          repo: { path: repoPath, include: [], exclude: [] },
          constraints: { max_tokens: 1024, latency_ms: 60000 },
          goal: message,
        },
        metadata: {
          mode_hint: "chat",
          conversation: conversation,
          memory_context_ids: Array.from(memoryState.selected),
          session_id: sessionId,
        },
        output_contract: { expected_files: [] },
      };
    }

    async function fetchFinalResult(taskId, pendingBubble) {
      try {
        const resp = await fetch(`${state.base.replace(/\/$/, "")}/v1/tasks/${taskId}/final`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        const text = data.result || data.content || data.note || JSON.stringify(data, null, 2);
        renderMarkdown(pendingBubble.body, text);
        conversation.push({ role: "assistant", content: text });
        renderContextUsage(pendingBubble.body, data);
        if (Array.isArray(data.follow_up_steps) && data.follow_up_steps.length) {
          const follow = document.createElement("div");
          follow.className = "mt-4 rounded-2xl border border-amber-400/40 bg-amber-500/10 px-3 py-2 text-sm text-amber-200";
          const title = document.createElement("div");
          title.className = "font-semibold mb-1 uppercase tracking-wide text-amber-300";
          title.textContent = "Follow-up";
          const list = document.createElement("ul");
          list.className = "list-disc space-y-1 pl-5";
          data.follow_up_steps.forEach(step => {
            const item = document.createElement("li");
            item.textContent = step;
            list.appendChild(item);
          });
          follow.appendChild(title);
          follow.appendChild(list);
          pendingBubble.body.appendChild(follow);
        }
        pendingBubble.container.classList.remove("processing");
        if (pendingBubble.status) {
          pendingBubble.status.classList.remove("shimmer-text");
        }
        if (pendingBubble.status) {
          const elapsed = pendingBubble.started ? Math.max(0, (performance.now() - pendingBubble.started) / 1000) : null;
          pendingBubble.status.textContent = elapsed ? `Completed in ${elapsed.toFixed(1)}s.` : "Completed.";
          pendingBubble.status.classList.remove("text-slate-400", "text-slate-200", "italic", "text-amber-300", "text-rose-300");
          pendingBubble.status.classList.add("text-emerald-300");
        }
      } catch (err) {
        pendingBubble.container.classList.remove("processing");
        if (pendingBubble.status) {
          pendingBubble.status.classList.remove("shimmer-text");
        }
        pendingBubble.body.textContent = `Unable to fetch final response: ${err.message || err}`;
      } finally {
        disableComposer(false);
      }
    }

    function attachEventStream(taskId, pendingBubble) {
      if (state.eventSource) {
        state.eventSource.close();
        state.eventSource = null;
      }
      const endpoint = `${state.base.replace(/\/$/, "")}/v1/stream/${taskId}`;
      const es = new EventSource(endpoint);
      state.eventSource = es;
      const handleDone = (payload) => {
        if (state.eventSource) {
          state.eventSource.close();
          state.eventSource = null;
        }

        if (payload && payload.pending_final) {
          pendingBubble.body.textContent = "Still working… retrieving final result.";
          fetchFinalResult(taskId, pendingBubble);
          return;
        }

        const text = payload.content || payload.message || payload.result || "";
        const hasImmediateContent = Boolean(text && text.trim().length);

        if (!hasImmediateContent) {
          pendingBubble.body.textContent = "Still working… retrieving final result.";
          fetchFinalResult(taskId, pendingBubble);
          return;
        }

        renderMarkdown(pendingBubble.body, text);
        conversation.push({ role: "assistant", content: text });
        renderContextUsage(pendingBubble.body, payload);
        pendingBubble.container.classList.remove("processing");
        if (pendingBubble.status) {
          pendingBubble.status.classList.remove("shimmer-text");
        }
        if (pendingBubble.status) {
          const elapsed = pendingBubble.started ? Math.max(0, (performance.now() - pendingBubble.started) / 1000) : null;
          pendingBubble.status.textContent = elapsed ? `Completed in ${elapsed.toFixed(1)}s.` : "Completed.";
          pendingBubble.status.classList.remove("text-slate-400", "text-slate-200", "italic");
          pendingBubble.status.classList.add("text-emerald-300");
        }
        if (Array.isArray(payload.follow_up_steps) && payload.follow_up_steps.length) {
          const follow = document.createElement("div");
          follow.className = "mt-4 rounded-2xl border border-amber-400/40 bg-amber-500/10 px-3 py-2 text-sm text-amber-200";
          const title = document.createElement("div");
          title.className = "font-semibold mb-1 uppercase tracking-wide text-amber-300";
          title.textContent = "Follow-up";
          const list = document.createElement("ul");
          list.className = "list-disc space-y-1 pl-5";
          payload.follow_up_steps.forEach(step => {
            const item = document.createElement("li");
            item.textContent = step;
            list.appendChild(item);
          });
          follow.appendChild(title);
          follow.appendChild(list);
          pendingBubble.body.appendChild(follow);
        }
        if (payload.zip_url && (payload.content || payload.files || payload.follow_up_steps || text.trim())) {
          const link = document.createElement("a");
          link.href = payload.zip_url;
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          link.className = "mt-3 inline-flex items-center gap-2 rounded-xl border border-indigo-400/40 bg-indigo-500/10 px-3 py-1.5 text-xs text-indigo-200 hover:bg-indigo-500/20";
          link.textContent = "Download ZIP";
          pendingBubble.body.appendChild(link);
        }
        disableComposer(false);
      };

      es.addEventListener("done", evt => {
        if (!evt.data) {
          handleDone({});
          return;
        }
        try {
          const payload = JSON.parse(evt.data);
          handleDone(payload);
        } catch {
          handleDone({});
        }
      });

      es.onmessage = evt => {
        if (!evt.data) return;
        try {
          const payload = JSON.parse(evt.data);
          if (payload.message && pendingBubble.status) {
            let statusText = payload.message;
            if (typeof payload.elapsed_seconds === "number") {
              statusText = `${statusText} (${payload.elapsed_seconds.toFixed(1)}s)`;
            }
            pendingBubble.status.textContent = statusText;
            pendingBubble.status.classList.remove("text-emerald-300", "text-rose-300", "text-amber-300", "text-slate-400", "italic");
            pendingBubble.status.classList.add("text-slate-200");
            pendingBubble.status.classList.add("shimmer-text");
          }
          if (payload.status === "done") {
            handleDone(payload);
          } else if (payload.status === "error") {
            pendingBubble.container.classList.remove("processing");
            pendingBubble.body.classList.remove("shimmer-text");
            pendingBubble.body.textContent = `Error: ${payload.error || "unknown"}`;
            if (pendingBubble.status) {
              pendingBubble.status.textContent = "Something went wrong.";
              pendingBubble.status.classList.remove("text-emerald-300", "text-slate-200", "shimmer-text");
              pendingBubble.status.classList.add("text-rose-300");
            }
            disableComposer(false);
            if (state.eventSource) {
              state.eventSource.close();
              state.eventSource = null;
            }
          } else if (payload.mode === "clarify" && payload.content) {
            renderMarkdown(pendingBubble.body, payload.content);
            conversation.push({ role: "assistant", content: payload.content });
            disableComposer(false);
            if (state.eventSource) {
              state.eventSource.close();
              state.eventSource = null;
            }
          }
        } catch (err) {
          console.error("Failed to parse SSE message", err);
        }
      };
      es.onerror = () => {
        pendingBubble.body.textContent = "Still thinking… collecting the final answer for you.";
        if (pendingBubble.status) {
          pendingBubble.status.textContent = "Reconnecting to fetch the final response…";
          pendingBubble.status.classList.remove("text-emerald-300", "text-slate-200");
          pendingBubble.status.classList.add("text-amber-300");
        }
        if (state.eventSource) {
          state.eventSource.close();
          state.eventSource = null;
        }
        fetchFinalResult(taskId, pendingBubble);
      };
    }

    async function sendMessage(event) {
      event.preventDefault();
      if (state.sending) return;
      const text = inputEl.value.trim();
      if (!text) return;
      if (!state.base) {
        alert("Set API Base first.");
        return;
      }
      disableComposer(true);
      renderMessage("user", text);
      inputEl.value = "";
      const pending = renderMessage("assistant", "", { persist: false, pending: true });
      pending.started = performance.now();

      try {
        const payload = toTaskPayload(text);
        const resp = await fetch(`${state.base.replace(/\/$/, "")}/v1/tasks`, {
          method: "POST",
          headers: {
            "content-type": "application/json",
            ...(state.key ? { "x-api-key": state.key } : {}),
          },
          body: JSON.stringify(payload),
        });
        if (!resp.ok) {
          const detail = await resp.text();
          throw new Error(detail || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        if (!data.task_id) {
          throw new Error("Task created but id missing.");
        }
        attachEventStream(data.task_id, pending);
      } catch (err) {
        console.error(err);
        pending.body.textContent = `Error: ${err.message || err}`;
        disableComposer(false);
      }
    }

    messagesEl.addEventListener("click", async (event) => {
      const copyBtn = event.target.closest(".copy-btn");
      const selectBtn = event.target.closest(".select-btn");
      if (!copyBtn && !selectBtn) return;
      const text = (copyBtn || selectBtn).dataset.code || "";
      if (copyBtn) {
        try {
          await navigator.clipboard.writeText(text);
          copyBtn.textContent = "Copied";
          copyBtn.classList.add("border-emerald-400", "text-emerald-200");
          setTimeout(() => {
            copyBtn.textContent = "Copy";
            copyBtn.classList.remove("border-emerald-400", "text-emerald-200");
          }, 1500);
        } catch (err) {
          console.error("Copy failed", err);
          copyBtn.textContent = "Copy failed";
          setTimeout(() => (copyBtn.textContent = "Copy"), 1500);
        }
      } else if (selectBtn) {
        const wrapper = selectBtn.closest(".relative");
        const codeBlock = wrapper ? wrapper.querySelector("pre") : null;
        if (codeBlock) {
          const range = document.createRange();
          range.selectNodeContents(codeBlock);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          selectBtn.textContent = "Selected";
          setTimeout(() => (selectBtn.textContent = "Select"), 1500);
        }
      }
    });

    apiBaseEl.addEventListener("change", () => {
      state.base = apiBaseEl.value.trim();
      rememberSettings();
    });
    apiKeyEl.addEventListener("change", () => {
      state.key = apiKeyEl.value.trim();
      rememberSettings();
    });
    memoryRefreshBtn.addEventListener("click", () => {
      fetchMemories(inputEl.value || (conversation[conversation.length - 1]?.content ?? ""));
    });
    memoryListEl.addEventListener("click", (event) => {
      const target = event.target.closest("button[data-id]");
      if (!target) return;
      toggleMemorySelection(target.dataset.id);
    });
    memoryUploadBtn.addEventListener("click", () => {
      memoryUploadInput.value = "";
      memoryUploadInput.click();
    });
    memoryUploadInput.addEventListener("change", async (event) => {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      await uploadMemoryArchive(file);
    });
      newChatBtn.addEventListener("click", () => {
        if (state.eventSource) {
          state.eventSource.close();
          state.eventSource = null;
        }
      clearConversation();
      disableComposer(false);
      inputEl.focus();
        memoryState.selected.clear();
        memoryState.results = [];
        memoryState.manualSelection = false;
      state.sessionId = "";
      sessionStorage.removeItem(SESSION_KEY);
      ensureSessionId();
      sessionStorage.setItem(SESSION_KEY, state.sessionId);
      updateMemoryPanel();
    });
    composerForm.addEventListener("submit", sendMessage);

    applyStateToInputs();
    ensureSessionId();
    inputEl.focus();
    updateMemoryPanel();
  </script>
</body>
</html>
