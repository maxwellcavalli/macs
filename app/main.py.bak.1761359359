from __future__ import annotations
from fastapi import FastAPI
from .sse_early_exit_mw import SSEEarlyExitMiddleware
from fastapi.middleware.cors import CORSMiddleware
from .api import router, hub
from .queue import JobQueue
from .logging_setup import setup_json_logging, get_logger
from .middleware import RequestIDMiddleware

setup_json_logging()
log = get_logger("bootstrap")

app = FastAPI(title="MACS API")



# Early-exit SSE when artifacts already exist
app.add_middleware(SSEEarlyExitMiddleware)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"],
)
app.add_middleware(RequestIDMiddleware)

app.include_router(router)

@app.on_event("startup")
async def _startup():
    # create and start the queue
    jobq = JobQueue(hub)
    await jobq.start()
    # expose via app.state (authoritative)
    app.state.job_queue = jobq
    # also set module global for older call sites
    from . import api as api_module
    api_module.job_queue = jobq
    log.info("startup complete")

@app.get("/")
async def root():
    return {"ok": True, "service": "macs-api"}

# --- Bandit endpoints mounted on the FastAPI app (app-level) ---
try:
    from fastapi import HTTPException, Request
    from .bandit_store import record_event as _bandit_record_event, get_stats as _bandit_get_stats

    _app = globals().get("app")
    if _app is not None:
        async def _bandit_record(payload: dict):
            model = str(payload.get("model") or "unknown")
            try:
                reward = float(payload.get("reward"))
            except Exception:
                raise HTTPException(status_code=422, detail="reward must be a number")
            meta = payload.get("meta") or {}
            _bandit_record_event(model, reward, meta)
            return {"ok": True}

        async def _bandit_stats():
            return {"ok": True, "stats": _bandit_get_stats()}

        async def __debug_routes(request: Request):
            return {"routes": [getattr(r, "path", None) for r in request.app.routes]}

        _app.add_api_route("/v1/bandit/record", _bandit_record, methods=["POST"])
        _app.add_api_route("/v1/bandit/stats", _bandit_stats, methods=["GET"])
        _app.add_api_route("/v1/__debug/routes", __debug_routes, methods=["GET"])
except Exception:
    # Never break startup if optional endpoints fail
    pass

# --- Simple DUEL submit endpoint (compat layer for local testing) ---
import os, json, uuid, threading, time
from pathlib import Path
from typing import Any, Dict, List
from fastapi import HTTPException

try:
    from .bandit_store import record_event as _bandit_record_event  # best-effort import
except Exception:
    _bandit_record_event = None  # type: ignore

_DUEL_ART_DIR = os.getenv("ARTIFACTS_DIR", "/data/artifacts")

def _duel_worker(task_id: str, prompt: str, models: List[str]) -> None:
    # Simulate scoring & persist bandit events
    for idx, m in enumerate(models):
        reward = 1.0 if idx == 0 else 0.5  # demo weights; adjust as needed
        try:
            if _bandit_record_event is not None:
                _bandit_record_event(m, reward, {"src": "duel_stub", "prompt": prompt})
        except Exception:
            pass
        time.sleep(0.05)

    # Write an artifact to trigger SSE early-exit (your middleware will detect the dir)
    root = Path(_DUEL_ART_DIR) / task_id
    root.mkdir(parents=True, exist_ok=True)
    (root / "result.json").write_text(
        json.dumps({"ok": True, "task_id": task_id, "prompt": prompt, "models": models}, ensure_ascii=False),
        encoding="utf-8"
    )

# Mounted on the actual FastAPI app
_app = globals().get("app")
if _app is not None:
    async def _duel_submit(payload: Dict[str, Any]):
        # Accept several shapes: {prompt, models}, {prompt, candidates:[{model}]}, or {input:{...}}
        prompt = (
            (payload.get("input") or {}).get("prompt")
            or payload.get("prompt")
            or (payload.get("goal") or "No prompt provided")
        )
        models: List[str] = []
        if "models" in payload:
            try:
                models = [str(x) for x in payload["models"] if x]
            except Exception:
                pass
        if not models and "candidates" in payload:
            try:
                models = [str(c.get("model")) for c in payload["candidates"] if c.get("model")]
            except Exception:
                pass

        if not models:
            raise HTTPException(status_code=422, detail="Provide models: ['modelA','modelB'] or candidates:[{model:...}]")
        if len(models) < 2:
            raise HTTPException(status_code=422, detail="At least two models required for duel")

        task_id = str(uuid.uuid4())
        threading.Thread(target=_duel_worker, args=(task_id, prompt, models), daemon=True).start()
        return {"task_id": task_id}

    _app.add_api_route("/v1/duel", _duel_submit, methods=["POST"])
